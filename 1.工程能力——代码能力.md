# 高质量代码

## 规范性

## 完整性

## 鲁棒性

# 数据结构

```c++
/*
	数据：描述客观事物的符号。
	数据元素：组成数据的、有一定意义的基本单位。
	数据项：一个数据元素可以由若干个数据项组成。（数据不可分割的最小单位）
	数据对象：是性质相同的数据元素的集合，是数据的子集。
	数据结构：是相互之间存在一种或多种特定关系的数据元素的集合
*/
```

![](E:\2---求职\附件\数据结构.png)

```C++
/*
	抽象数据类型 ADT
	标准格式：
		ADT 抽象数据类型名
		Data
			数据元素之间逻辑关系的定义
		Operation
			操作1
				初始条件
				操作结果描述
			操作2
				......
			操作n
				......
		endADT
*/
```

## 数组

```C++
/*
	数组：占据一块连续的内存并按照顺序存储数据
		创建数组需要指定数组的容量大小
*/
```

### 《剑指offer》—面试题3：数组中重复的数字

```C++
/*
	题目描述：
	在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为6的数{2,3,1,0,2,5}，那么对应的输出是第一个重复的数字2。
	
*/ 
```

```C++
/*	
	解决方案1（暴力解法）
	解决思路：
		对数组进行排序，然后从头到尾扫描数组，并将其与需要查重的元素进行对比，若相等，且数组本身有存在该元素的重复值，则找到需要寻找的重复元素
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）对数组进行排序
		（3）遍历数组，进行前后元素对比，若前后元素相等，返回true，反之进行遍历到数组末尾
		（4）若遍历到末尾，无重复元素，则返回false
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        // 边界条件
        if(numbers == nullptr || length < 0)
            return false;
        
        for(int i=0; i<length; i++)
        {
            if(numbers[i] < 0 || numbers[i] > length - 1)
                return false;
        }
        
        
        sort(numbers, numbers + length);
        
        for(int i=0; i<length; i++)
        {
            if(numbers[i] == numbers[i+1])
            {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```

```python
# python2.7.3实现

# -*- coding:utf-8 -*-
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        # write code here
        # 边界条件
        if len(numbers) <= 0:
            return False
        
        for num in numbers:
            if (num < 0) or (num > len(numbers)-1):
                return False
        
        # 对数组排序
        numbers.sort()
        
        for i in range(len(numbers) - 1):
            if numbers[i] == numbers[i+1]:
                duplication[0] = numbers[i]
                return True
        
        return False    
```

```c++
/*	
	解决方案2（技巧解法）
	解决思路：
		由于数组中的数字被限定在0~n-1的范围内，若数组中不存在重复元素，那么数组进行排序后，第i个位置存放的应该是元素i。
		基于上述思路，采用以下解题思路：
			从头到尾部遍历数组的元素，将扫描到下标为i的数字时，首先比较该数字（用m表示）是不是等于i。
			如果是，则扫描下一个数字；
			如果不是，则拿它和第m个数字进行比较，如果它与第m个数字相等，则找到第一个重复数字；
			如果不等，则将第i个数字和第m个数字进行交换，把m放回属于它的位置；
			然后重复上述步骤，直到我们发现第一个重复的数字
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）如解决思路中阐述
		
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        // 特殊输入
        if(numbers == nullptr || length < 0)
            return false;
         
        // 边界条件
        for(int i=0; i<length; i++)
        {
            if(numbers[i] < 0 || numbers[i] > length - 1)
                return false;
        }
        
        //
        for(int i=0; i<length; i++)
        {
            while(numbers[i] != i)
            {
                if(numbers[i] == numbers[numbers[i]])
                {
                    *duplication = numbers[i];
                    return true;
                }
            
                int temp = numbers[i];
                numbers[i] = numbers[temp];
                numbers[temp] = temp;
            }
        }
        return false;
    }
};
```

```c++
/*	
	解决方案3（哈希表实现）
	解决思路：
		构建简单的哈希表，从头到尾遍历数组元素，扫描到元素m时，在哈希表中对应的m位置加1，直到数组扫描完毕后，判断哈希表中大于1的元素，并在数组中找到其对应的元素记为重复的元素即可
		
	注意：这种解法并不使用于数组元素很多很多的时候，因为哈希表需要初始设定其容量大小
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）对数组元素遍历并统计每个元素出现的次数存入哈希表中
		（3）遍历哈希表，找出次数大于1的对应在数组中的元素
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        if(numbers == nullptr|| length <= 0) 
            return false;
        
        int hashTable[255] = {0};
        
        for(int i=0; i<length; i++)
        {
            hashTable[numbers[i]]++;
        }

        for(int i=0; i<length; i++)
        {
            if(hashTable[numbers[i]] > 1)
            {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```



### 《剑指offer》—面试题4：二维数组中的查找

```c++
/*
	题目描述：
	在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
*/ 
```

```c++
/*	
	解决方案1
	解决思路：
		利用题目描述中二维数组的特性，从左往右的每行和从上往下的每列都递增，因此可以选择从数组的右上角或左下角开始比较判断，剔除相应的行和列，最终能定位到相应的元素。
	解决步骤：（可以从左下角开始，思路一致）
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）定位到数组（n行xn列）的右上角，将其与目标元素进行比较
			（2.1）若目标元素等于数组右上角的元素，则返回真
			（2.2）若目标元素大于数组右上角的元素，则剔除右上角元素所在行，可选元素的数组为n-1行Xn-1列
			（2.3）若目标元素小于数组右上角的元素，则剔除右上角元素所在列，可选元素的数组为n-1行Xn-1列
		（3）循环执行步骤（2），最终得到数组中存在目标元素，返回真，否则返回假
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool Find(int target, vector<vector<int> > array) 
    {
        int rows = array.size();
        int cols = array[0].size();
        if(array.empty())
        {
            return false;
        }
        
        int row = 0;
        int col = cols - 1;
        
        while(row < rows && col >=0)
        {
            if(array[row][col] == target)
            {
                return true;
            }
            else if(array[row][col] > target)
            {
                --col;
            }
            else
                ++row;
        }
        return false;
    }
};
```



### 《剑指offer》—面试题11：旋转数组的最小数字

```c++
/*
	题目描述：
	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/ 
```

```c++
/*	
	解决方案1（双指针法~二分查找）
	解决思路：
		根据题目描述，输入的为一个非减排序旋转数组，
		（1）可将其看作两个递增子数组。利用两个指针P1,P2分别指向旋转数组的头尾，将P1和P2的中间元素与P1（或P2）指向的元素不断比较，直到P1与P2相邻，且P1在P2前面，此时P2指向的元素为旋转数组最小的元素。
		（2）当不能将其看作两个递增子数组时，只能采用顺序查找的方法。
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）设置两个指针p1,p2分别指向旋转数组的头尾，并设置另一个指针mid=p1;
		（3）开始循环移动p1，p2，终止条件为p1大于p2
			（3.1）如果p2-p1==1，说明此时p2已经指向了旋转数组的最小元素，直接输出
			（3.2）若p1，p2，mid指向的元素均相等，此时的旋转数组划分为两个递增子数组，采用顺序查找方法
			（3.3）若p1指向的元素小于mid指向的元素，说明此时的mid指向的元素位于前面的子数组，将p1=mid
			（3.3）若p2指向的元素大于mid指向的元素，说明此时的mid指向的元素位于后面的子数组，将p2=mid
		（4）循环结束后，输出最小元素
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) 
    {
        if(rotateArray.size() == 0)
            return 0;
        
        int p1 = 0;
        int p2 = rotateArray.size() - 1;
        int mid = p1;    // 当旋转数组仍然为非减排序数组时，第一个元素就是最小元素
        
        while(rotateArray[p1] >= rotateArray[p2])
        {
            if(p2 - p1 == 1)
            {
                mid = p2;
                return rotateArray[mid];
            }
            
            int mid = ( p1 + p2) / 2;
            // 三个位置的元素都相等，只能采用顺序查找
            if(rotateArray[p1] == rotateArray[mid] && rotateArray[p2] == rotateArray[mid])
                return MinInOrder(rotateArray);
            
            // 中间元素位于前面的递增子数组
            if(rotateArray[p1] <= rotateArray[mid])
                p1 = mid;
            
            // 中间元素位于后面的递增子数组
            else if(rotateArray[p2] >= rotateArray[mid])
                p2 = mid;
        }
        return rotateArray[mid];
    }
    
    int MinInOrder(vector<int> array)
    {
        int tmp = array[0];
        int length = array.size();
        for(int i=1; i<length; i++)
        {
            if(tmp > array[i])
                tmp = array[i];
        }
        return tmp;
    }
};
```



### 《剑指offer》—面试题21：调整数组顺序使奇数位于偶数前面

```c++
/*
	题目描述：
	输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
*/
```

```c++
/*	
	解决方案1（双指针法）
	解决思路：
		根据题目描述，要求最终得到的数组为前半部分全是奇数，后半部分全是偶数。可定义两个指针p1，p2分别指向数组的头尾，若p1指向偶数，p2指向奇数，则交换二者指向的元素，其他情况不交换，p1不断往后移，p2不断往前移直到所有的奇数交换到数组前半部分。
	解决步骤：
		（1）
		（2）
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    void reOrderArray(vector<int> &array) 
    {
        
    }
};
```

```c++
/*	
	解决方案2（中间动态数组法）
	解决思路：
		根据题目描述，要求最终得到的数组为前半部分全是奇数，后半部分全是偶数。定义一个新的动态数组，先后两次遍历数组，第一次取出所有奇数存入新数组，第二次取出所有偶数存入新数组，最后把新数组赋值给原数组
	解决步骤：
		（1）处理特殊输入（数组长度），并定义新的动态数组result
		（2）第一次遍历数组，取出奇数存入result
		（3）第二次遍历数组，取出偶数存入result
		（4）result赋给原数组
*/
```

```c++
// c++11（clang++3.9）实现

class Solution{
public:
    void reOrderArray(vector<int> &array) 
    {
        vector<int> result;
        int length = array.size();
        if(length == 0)
            return;
        
        for(int i=0; i<length; i++)
        {
            if(array[i] % 2 == 1)
                result.push_back(array[i]);
        }
        for(int i=0; i<length; i++)
            {
            if(array[i] % 2 == 0)
                result.push_back(array[i]);
        }
        array = result;
    }
};
```



### 《剑指offer》—面试题39：数组中出现次数超过一半的数字

```c++
/*
	题目描述：
	数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
*/
```

```c++
/*	
	解决方案1
	解决思路：
		根据题目
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```



### 《剑指offer》—面试题42：连续子数组的最大和

```c++
/*
	题目描述：
	HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
*/
```

```c++
/*	
	解决方案1（分析数组的规律）
	解决思路：
		根据题目描述，得到数组中连续元素相加的最大和，注意不能交换数组中元素的位置。从前到后遍历数组，每累加一次元素，计算出一个和，并将其与上一次的和进行比较，若和为负数，则舍弃该和，从该元素的下一个元素重新开始累加；若和为整数，则继续不断累加，不断比较每次累加的和，比较得出最大和
	解决步骤：
		（1）处理特殊输入（数组长度），并定义当前与最后的最大和
		（2）从头到尾遍历数组
			（2.1）若当前最大和为负数，舍弃当前最大和，将其重新赋值为数组下一个元素
			（2.2）若当前最大和为非负数，保留当前最大和，继续累加
			（2.3）比较当前最大和与最后最大和，更新最后最大和
		（3）输出最后最大和
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) 
    {
        int length = array.size();
        if(length == 0)
            return 0;
        
        
        int lastGreatestSum = 0x80000000;
        int curGreatestSum = 0;
        for(int i=0; i<length; i++)
        {
            // 若当前求和为负数，舍弃当前和，将其设置为数组下一个元素
            if(curGreatestSum < 0)
                curGreatestSum = array[i];
            // 若当前求和为非负数，保留当前和，继续累加
            else
                curGreatestSum += array[i];
            
            if(curGreatestSum > lastGreatestSum)
                lastGreatestSum = curGreatestSum;
        }
        return lastGreatestSum;
    }
};
```

### 《剑指offer》—面试题45：把数组排成最小的数

```c++
/*
	题目描述：
	输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
*/
```

```c++
/*	
	解决方案1
	解决思路：（排序+数字转字符串）
		将数组以特定的方法的进行排序，然后从头到尾遍历数组每个元素，将其转换为字符串后进行相加，最后的得到最小的数。
		特定的方法：先将两个相邻数字转换为字符，按先后不同顺序相加，比较两次相加得到的最小数
	解决步骤：
	（1）首先处理特殊输入，空数组
	（2）对数组进行排序，特定的方法。
	（3）遍历数组，整数转字符串后累加
	（4）输出最小的数
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    string PrintMinNumber(vector<int> numbers) 
    {
        int length = numbers.size();
        if(length == 0)
            return "";
        
        sort(numbers.begin(), numbers.end(), cmp);
        string result;
        
        for(int i=0; i<length; ++i)
        {
            result += to_string(numbers[i]);
        }
        return result;
    }
    
    static bool cmp(int a, int b)
    {
        string A = to_string(a) + to_string(b);
        string B = to_string(b) + to_string(a);
        return A < B;
    }
};
```



### 《剑指offer》—面试题51：数组中的逆序对

```c++
/*
	题目描述：
	在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
	
	输入描述:
		题目保证输入的数组中没有的相同的数字

		数据范围：
			对于%50的数据,size<=10^4
			对于%75的数据,size<=10^5
			对于%100的数据,size<=2*10^5
			
*/
```

```c++
/*	
	解决方案1（分治+归并排序）
	解决思路：
		根据题目描述，首先将数组划分为
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

### 《剑指offer》—面试题53：在排序数组中查找数字

##### 题目1：数字在排序数组中出现的次数

```c++
/*
	题目描述：
	统计一个数字在排序数组中出现的次数。例如，输入排序数组{1，2，3，3，3，3，4，5}和数字3，由于3在这个数组中出现了4次，因此输出4
*/
```

```c++
/*	
	解决方案1（二分查找+递归）
	解决思路：
		通过二分查找与递归分别找出第一个数字所在位置，以及最后一个数字所在位置。
	解决步骤：
		（1）首先考虑特殊输入，空数组
		（2）找出数组中第一次出现该数字k的位置，二分查找判别条件是将k与中间位置元素比较
			（2.1）若中间位置的元素刚好等于k：
				（2.1.1）若索引等于0或其位置的前一个元素不等于k，那么找到k出现地第一次位置
				（2.1.2）否则，将尾部索引移动到中间索引的前一个位置，便于进行下一次判断
			（2.2）若中间位置的元素大于k，说明k出现在数组的前半段，将尾部索引移动到中间索引的前一个位置
			（2.3）若中间位置的元素小于k，说明k出现在数组的后半段，将头部索引移动到中间索引的后一个位置
		（3）递归调用步骤（2），得到k第一次出现的位置；
		（4）找出数组中最后出现该数字k的位置，步骤和思想与步骤（2）类似
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) 
    {
        
        int times = 0;
        int length = data.size();
        int first = 0;
        int last = 0;
        if(length == 0)
            return 0;
        
        first = GetFirstK(data, length, k, 0, length-1);
        last = GetLastK(data, length, k, 0, length-1);
        
        if(first > -1 && last > -1)
            times = last - first + 1;
        
        return times;
    }
    
    int GetFirstK(vector<int> &data, int length, int k, int start, int end)
    {
        if(start > end)
            return -1;
        
        int midIndex = (start + end)/2;
        int midData = data[midIndex];
        
        if(midData == k)
        {
            if(midIndex > 0 && (data[midIndex-1] != k) || (midIndex == 0))
                return midIndex;
            else
                end = midIndex - 1;
        }
        else if(midIndex > k)
            end = midIndex - 1;
        else
            start = midIndex + 1;
        
        return GetFirstK(data, length, k, start, end);
    }
    
    int GetLastK(vector<int> &data, int length, int k, int start, int end)
    {
        if(start > end)
            return -1;
        
        int midIndex = (start + end)/2;
        int midData = data[midIndex];
        
        if(midData == k)
        {
            if(midIndex < length - 1 && (data[midIndex+1] != k) || (midIndex == length - 1))
                return midIndex;
            else
                start = midIndex + 1;
        }
        else if(midIndex < k)
            start = midIndex + 1;
        else
            end = midIndex - 1;
        
        return GetLastK(data, length, k, start, end);
    }
};
```

```c++
/*	
	解决方案2（二分查找+迭代）
	解决思路：
		通过二分查找与迭代分别找出第一个数字所在位置，以及最后一个数字所在位置。
	解决步骤：
		（1）首先考虑特殊输入，空数组
		（2）找出数组中第一次出现该数字k的位置，二分查找判别条件是将k与中间位置元素比较
		（3）
			
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) 
    {
        
        int times = 0;
        int length = data.size();
        if(length == 0)
            return 0;
        
        int first = GetFirstK(data, length, k, 0, length-1);
        int last = GetLastK(data, length, k, 0, length-1);
        
        if(first > -1 && last > -1)
            times = last - first + 1;
        
        return times;
    }
    
    // 循环实现
    int GetFirstK(vector<int> &data, int length, int k, int start, int end)
    {
        int mid = (start + end) >> 1;	// 等价于mid = (start + end) / 2;
        while(start <= end)
        {
            if(data[mid] > k)
            {
                end = mid - 1;
            }
            else if(data[mid] < k)
            {
                start = mid + 1;
            }
            else if(data[mid] == k && data[mid - 1] == k)
            {
                end = mid - 1;
            }
            else
            {
                return mid;
            }
            mid = (start + end) >> 1;
        }
        return -1;
    }
    
    int GetLastK(vector<int> &data, int length, int k, int start, int end)
    {
        int mid = (start + end) >> 1;
        while(start <= end)
        {
            if(data[mid] > k)
            {
                end = mid - 1;
            }
            else if(data[mid] < k)
            {
                start = mid + 1;
            }
            else if(mid + 1 < length && data[mid + 1] == k)
            {
                start = mid + 1;
            }
            else
            {
                return mid;
            }
            mid = (start + end) >> 1;
        }
        return -1;
    }
};
```



### 《剑指offer》—面试题56：数组中数字出现的次数

##### 题目1：数组中只出现一次的两个数字

```c++
/*
	题目描述：
	一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
*/
```

```c++
/*	
	解决方案1(位运算：异或)
	解决思路：
		首先根据异或的特性（任何数与其本身异或为0），将数组中的元素从头到尾异或，最终得到的数一定是数组中只出现一次的两个数字的异或值value，然后将value的二进制位中第一次出现1的位置N为划分标准，将数组划分为两个数组，第一个子数组的所有元素的二进制位的第N位为1，且仅包含一个出现一次的数组；另一个子数组的所有元素的二进制位的第N位为0，且仅包含一个出现一次的数组。然后再用异或处理两个子数组得到两个只出现一次的数字。
	解决步骤：
	（1）首先处理特殊输入，输入数组的长度是否小于2
	（2）设置value初始值为0（0与任何数异或等于其本身），从头到尾遍历整个数组，将value从头到尾与其元素异或得到最终用于划分数组的value
	（3）找到value的二进制位中第一个1出现的位置（二进制位中从左往右数第一个1）
	（4）根据步骤（3）所得位1所在位置，划分数组，并重新异或各个子数组，得到最后的出现一次的两个数字。
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) 
    {
        /*
            解题思路：
            （1）首先，考虑特殊输入，数组长度小于2，函数结束
            （2）对数组元素从前往后进行异或计算，最后得到的异或值
            （3）处理异或值用于将数组划分为两个子数组；（从右往左数第1个出现1的二进制位用于划分）
            （4）对划分后的子数组分别进行num1和num2的异或处理，异或标志位为步骤（3）所得
        */
        int length = data.size();
        if(length < 2)
            return;
        
        int resultExclusiveOR = 0;
        for(int i=0; i<length; ++i)
            resultExclusiveOR ^= data[i];
        
        unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR);
        
        *num1 = *num2 = 0;
        for(int j=0; j<length; ++j)
        {
            if(IsBit1(data[j], indexOf1))
                *num1 ^= data[j];
            else
                *num2 ^= data[j];
        }
    }
    
    // 用来在整数num的二进制表示中找到从左往右第一个1的位置
    unsigned int FindFirstBitIs1(int num)
    {
        int indexBit = 0;
        while(((num & 1) == 0) && (indexBit < 8 * sizeof(int)))
        {
            num = num >> 1;
            ++indexBit;
        }
        return indexBit;
    }
    
    // 判断在num的二进制表示中从右边数起的indexBit位是不是1
    bool IsBit1(int num, unsigned int indexBit)
    {
        num = num >> indexBit;
        return (num & 1);
    }
};
```



### 《剑指offer》—面试题57：和为s的数字

##### 题目1：和为s的两个数字

```c++
/*
	题目描述：
	输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的
*/
```

```c++
/*	
	解决方案1（双指针法）
	解决思路：
		由于递增排序的数组，因此找到的第一组和为S的即为乘积最小的。通过设置两个指针p1，p2分别指向数组的头尾，将其指向的值相加，若小于S，则p1往后移动；若大于S，则p2往前移动；若等于S，输出答案。
	解决步骤：
		（1）
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) 
    {
        vector<int> result;
        int length = array.size();
        
        if(length == 0)
            return result;
        
        int start = 0;
        int end = length - 1;
        
        while(end > start)
        {
            long long curSum = array[start] + array[end];
            
            if(curSum == sum)
            {
                result.push_back(array[start]);
                result.push_back(array[end]);
                break;
            }
            else if(curSum > sum)
                end--;
            else
                start++;
        }
        return result;
    }
};
```

##### 题目2：和为s的连续正数序列

```c++
/*
	题目描述：
	小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
	
	输出描述:
	输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
*/
```



### 《剑指offer》—面试题66：构建乘积数组

```c++
/*
	题目描述：
	给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

------

### 

## 字符串

```c++
/*
	定义：字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。
*/
```

### 《剑指offer》—面试题5：替换空格

```c++
/*
	题目描述：
	请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
*/
```

```c++
/*	
	解决方案1（双指针法）
	解决思路：
		首先统计出字符串的空格数，然后根据空格数目扩充后的字符串的长度 = 原字符串长度 + 空格数目*2；接着设置两个指针p1，p2，分别指向扩充前字符串的尾部，扩充后字符串的尾部，不断移动p1，将p1指向的元素复制给p2，同时两者均向前移动，当p1遇到空格，则在p2前插入%20，p2向前移动3格。
	解决步骤：
		（1）遍历字符串str，统计空格个数
       	（2）扩充字符串，长度为原来字符串长度 + 空格数乘以2
       	（3）设置两个指针P1,P2,分别指向原字符串的末尾和扩充字符串的末尾
       	（4）向前移动P1,将P1指向的字符复制到P2指向的的位置后，P2向前移动1格
        （5）循环执行步骤（4），直到P1遇到第一个空格，P1向前移动1格，P2之前插入字符串%20，P2向前移动3格
        （6）循环执行步骤（4）（5）直到P1=P2
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
	void replaceSpace(char *str,int length) 
    {
        if(str==nullptr || length<=0){
            return;
        }
        
        int originLength = 0;
        int numOfBlank = 0;
        int i = 0;
        while(str[i] != '\0')
        {
            ++originLength;
            if(str[i] == ' ')
            {
                ++numOfBlank;
            }
            ++i;
        }
        
        int newLength = originLength + numOfBlank * 2;
        if(newLength > length)
            return;
        
        int p1 = originLength;
        int p2 = newLength;
        while(p1 >= 0 && p2 > p1)
        {
            if(str[p1] == ' ')
            {
                str[p2--] = '0';
                str[p2--] = '2';
                str[p2--] = '%';
            }
            else
            {
                str[p2--] = str[p1];
            }
            --p1;
        }
 	}
};
```

### 《剑指offer》—面试题17：打印从1到最大的n位数

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

### 《剑指offer》—面试题19：正则表达式匹配

```c++
/*
	题目描述：
	请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配
*/
```

```c++
/*	
	解决方案1
	解决思路：
		首先，考虑特殊情况：
         （1）两个字符串都为空，返回true
         （2）当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法
         	匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成
            功的，比如第二个字符串是“a*a*a*a*”,由于‘*’之前的元素可以出现0次，
            所以有可能匹配成功）
            
    	之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern
    	下一个字符可能是‘*’， 这里我们分两种情况讨论：pattern下一个字符为‘*’或
    	不为‘*’：
          （1）pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果
            匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的
            “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的
            当前字符为‘.’,同时s的当前字符不为‘\0’。
         （2）pattern下一个字符为‘*’时，稍微复杂一些，因为‘*’可以代表0个或多个。
            这里把这些情况都考虑到：
               （2.1）当‘*’匹配0个字符时，s当前字符不变，pattern当前字符后移两位，
                跳过这个‘*’符号；
               （2.2）当‘*’匹配1个或多个时，s当前字符移向下一个，pattern当前字符
                不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，
                由于s移到了下一个字符，而pattern字符不变，就回到了上边的情况a；
                当匹配多于一个字符时，相当于从s的下一个字符继续开始匹配）
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

//递归实现
class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if (str == nullptr || pattern == nullptr)
            return false;
        
        return matchCore(str, pattern);
    }
      
    bool matchCore(char* str, char* pattern)
    {
        // 字符串和模式均为空，匹配
        if (*str == '\0' && *pattern == '\0') 
            return true;
        // 字符串不为空，模式为空，无法匹配
        if (*str != '\0' && *pattern == '\0') 
            return false;
        
        // 模式的下一个字符为'*'
        if (*(pattern + 1) == '*')
        {
            if (*str == *pattern || (*pattern == '.' && *str != '\0'))
                return matchCore(str + 1, pattern) || matchCore(str, pattern + 2);
            else
                return matchCore(str, pattern + 2);
        }
        // 模式的下一个字符不为'*'
        if (*str == *pattern || (*pattern == '.' && *str != '\0'))
            return matchCore(str+1, pattern+1);
          
        return false;
    }
};
```



### 《剑指offer》—面试题20：表示数值的字符串

```c++
/*
	题目描述：
	请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”，“5e2”，“-123”，
	“3.1416”和“-1E-16”都表示数值。但是“12e”，“1a.123”，“1.2.3”，“+-5”，“12e+4.3”都不是。
*/
```

```c++
/*	
	解决方案1
	解决思路：
		首先明确表示数值的字符串的模式是 A.B(e|E)C 或者 .B(e|E)C，其中
			A为整数部分，可以含有+或-号或没有符号，并以0~9开头的数位串			    （非必须）
			B为小数部分，不能含有+或-号等符号，也是包含0~9的数位串 			 	     （必须）
			C为指数部分，可以含有+或-号或没有符号，并以0~9开头的整数数位串，不能含有小数 （非必须）
	解决步骤：
		（1）考虑特殊输入，输入字符指针为空，则返回false
        （2）开始判断字符串的整数部分，首先判断是否存在+-号,然后判断是否存在0~9的数值部分
        （3）判断字符串的小数部分，是数值存在3种情况：
                                    没有整数数值：.123
                                    没有小数数值：123.
                                    都有：123.222
        （4）判断字符串的指数部分，是数值时仅有一种情况：12e12，即e的前面必须有数字，e的后面必须是整数（有无符号不影响）
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool isNumeric(char* string)
    {
        //  特殊输入
        if(string == nullptr)
            return false;
        
        // 整数部分
        bool numeric = scanInteger(&string);    // 对指针的引用
        // 小数部分
        if(*string == '.')
        {
           ++string;
            numeric = scanUnsignedInteger(&string) || numeric;
        }
        // 指数部分
        if(*string == 'e' || *string == 'E')
        {
           ++string;
            numeric = numeric && scanInteger(&string);
        }
        return numeric && *string == '\0';    // 为数值且字符串存在'\0'
    }
    
    bool scanUnsignedInteger(char **string)
    {
        char* before = *string;
        while(**string != '\0' && **string >= '0' && **string <= '9')
        {
            ++(*string);
        }
        return *string > before;    
        /* 
        	为真，表明此时字符串指针指向了小数点，而before指向的是帧数部分的数字，
        	小数点的ASCII码大于数字的ASCII码,因此存在小数或其他部分，返回true，反之返回false
        */
    }
    
    bool scanInteger(char **string)
    {
        // 判断是否存在正负号，将字符串指针后移
        if(**string == '+' || **string == '-')
        {
            ++(*string);    // 指向字符串的下一个字符
        }
        return scanUnsignedInteger(string);
    }
};
```



### 《剑指offer》—面试题38：字符串的排列

![1558592457307](E:\2---求职\附件\字符串的排列.png)

```c++
/*
	题目描述：
	输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
	
	输入描述：
	输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
		
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
class Solution {
public:
    vector<string> Permutation(string str) 
    {
        if(str.length() == 0)
            return result;
        Permutation1(str,0);
        sort(result.begin(),result.end());
        return result;
    }
    
    void Permutation1(string str, int begin)
    {
        if(begin == str.length())
        {
            result.push_back(str);
            return ;
        }
        
        for(int i = begin; str[i]!='\0'; i++)
        {
            if(i != begin && str[begin] == str[i])
                continue;
            swap(str[begin], str[i]);
            Permutation1(str, begin+1);
            swap(str[begin], str[i]);
        }
    }
    
private:
    vector<string> result;
};
```



### 《剑指offer》—面试题46：把数字翻译成字符串

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```



### 《剑指offer》—面试题48：最长不含重复字符的子字符串

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```



### 《剑指offer》—面试题50：第一个只出现一次的字符

```c++
/*
	题目描述：
	在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）
*/
```

```c++
/*	
	解决方案1（哈希表）
	解决思路：
		构建一个哈希表，键为字符的ASCII码，值为该字符出现的次数，遍历两次字符串，第一次统计所有字符的次数，第二次统计第一个只出现一次的字符
	解决步骤：
		参考解决思路
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int FirstNotRepeatingChar(string str) 
    {
        if(str.size() == 0)
            return -1;
        int length = str.size();
        char hashTable[256] = {0};
        
        for(int i=0; i<length; i++)
        {
             hashTable[str[i]]++;
        }
        
        for(int i=0; i<str.size(); i++)
        {
            if(hashTable[str[i]] == 1)
                return i;
        }
        return 0;
    }
};
```



### 《剑指offer》—面试题58：翻转字符串

##### 题目1：翻转单词顺序

```c++
/*
	题目描述：
	牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
*/
```

```c++
/*	
	解决方案1（双指针法）
	解决思路：
		先翻转整个句子，在重新翻转每个单词及其标点符号
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    string ReverseSentence(string str) 
    {
        int length = str.length();
        if(length == 0) 
            return "";
        
        // 翻转整个字符串
        int begin=0;
        int end=0;
        Reverse(str, 0, length-1);
        
        // 翻转每个单词（双指针或叫做快慢指针）
        begin = end = 0;
        while(str[begin] != '\0')
        {
            if(str[begin] == ' ')
            {
                begin++;
                end++;
            }
            else if(str[end] == ' '|| str[end] == '\0')
            {
                Reverse(str, begin, --end);
                begin = ++end;
            }
            else 
                end++;
        }
        return str;
    }
    
    
    void Reverse(string &str, int begin, int end)
    {
        while(begin < end)
        {
            swap(str[begin++], str[end--]);
        }
    }
};
```

##### 题目2：左旋转字符串

```c++
/*
	题目描述：
	汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    string LeftRotateString(string str, int n) 
    {
        /*
            解题思路：
            （1）字符串分为两部分，分别翻转这两部分
            （2）再重新翻转（1）得到的字符串
        */
        
        int length = str.size();
        if(!str.empty() && n <= length)
        {
            if(n >= 0 && n <= length)
            {
                int firstStart = 0;
                int firstEnd = n - 1;
                int secondStart = n;
                int secondEnd = length - 1;
 
                // 翻转字符串的前面n个字符
                Reverse(str, firstStart, firstEnd);
                // 翻转字符串的后面部分
                Reverse(str, secondStart, secondEnd);
                // 翻转整个字符串
                Reverse(str, firstStart, secondEnd);
            }
        }
        return str;
    }
    
    void Reverse(string &str, int begin, int end)
    {
        while(begin < end)
        {
            swap(str[begin++], str[end--]);
        }
    }
};
```



### 《剑指offer》—案例一：把字符串转换成整数

```c++
/*
	题目描述：
	将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。
	
	输入描述:
		输入一个字符串,包括数字字母符号,可以为空
	输出描述:
		如果是合法的数值表达则返回该数字，否则返回0
*/
```

```c++
/*	
	解决方案1
	解决思路：
		主要需要考虑正负号、特殊输入空字符串""、最大的正整数、最小的负整数等。
	解决步骤：
		（1）首先处理特殊输入，设置全局变量minus用于判断是否含有符号
		（2）滤掉空格，读取除空格外的字符串的第一个字符是否为正负号，给minus置位
			（2.1）若符号（不）存在且符号位后字符不是字符串结束符'\0'，则进行遍历
			（2.2）若符号（不）存在且符号位后字符是字符串结束符'\0'，则输出0
		（3）继（2.1）后执行
			（3.1）后继字符不为数字，直接输出0
			（3.2）后继字符为数字，遍历每个字符，直到'\0'后输出数字（同时进行溢出判别）
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int StrToInt(string str) 
    {
        bool minus = false;
        long long num = 0;
        int length = str.size();
        int index = 0;    // 用于遍历字符串
        
        // 处理特殊输入
        if(length == 0)
            return 0;
        
        // 滤掉前面的空格
        while(str[index] == ' ')
            index++;
        
        // 数字符号判断
        if(str[index] == '+')
            index++;
        
        else if(str[index] == '-')
        {
            index++;
            minus = true;
        }
        
        if(str[index] != '\0')
            num = StrToIntCore(str, minus, index);
        
        return (int)num;
    }
    
    long long StrToIntCore(string str, bool minus, int index)
    {
        long long num = 0;
        
        while(str[index] != '\0')
        {
            if(str[index] > '0' && str[index] < '9')
            {
                int flag = minus ? -1:1;
                num = num * 10 + flag * (str[index] - '0');
                
                // 数字溢出判断：最大正整数/最小负整数
                if((!minus && num > 0x7FFFFFFF) || (minus && num < (signed int)0x80000000))
                {
                    num = 0;
                    break;
                }
                index++;
            }
            
            else
            {
                num = 0;
                break;
            }
        } 
        return num;
    }
};
```

------

### 

## 链表

```c++
/*
	定义：
	链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 
*/

// 链表的结构体定义
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
    val(x), next(NULL) {
    }
};
```



### 《剑指offer》—面试题6：从尾到头打印链表

```c++
/*
	题目描述：
	输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
		利用递归的思想，设置递归结束条件为读取到链表的末尾。每调用一次自身，读取一个链表结点，并且每次将每个结点对应的元素存储起来，当达到链表结点末尾时，开始返回到上一级调用函数处，利用一个临时动态数组，不断将元素从后往前插入到另一个动态数字中，最后实现链表从尾到头的元素存储
	解决步骤：
		参考解决思路
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<int> printListFromTailToHead(struct ListNode* head)
    {
        vector<int> value;
        if(head != nullptr)
        {
            value.insert(value.begin(), head->val);
            if(head->next != nullptr)
            {
                vector<int> tempVec = printListFromTailToHead(head->next);
                if(tempVec.size() > 0)
                    // 在value.begin()前插入tempVec.begin(), tempVec.end()间的所有元素
                    value.insert(value.begin(), tempVec.begin(), tempVec.end()); 
            }
        }
        return value;
    }
};
```

```c++
/*	
	解决方案2（迭代）
	解决思路：
		头插法，定义一个整型动态数组，然后遍历链表，不断将结点元素插入到begin()迭代器指向位置的前面，从而实现从尾到头存储脸变元素
	解决步骤：
		参考解决思路
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> value;
        if(head != nullptr)
        {
            value.insert(value.begin(), head->val);
            while(head->next != nullptr)
            {
                value.insert(value.begin(), head->next->val);
                head = head->next;
            }           
        }
        return value;
    }
};
```

```c++
/*	
	解决方案3（利用栈的特性）
	解决思路：
		利用栈的先进后出的特性，先遍历链表，将其元素入栈。再遍历栈，栈顶元素出栈并压入动态数组中
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) 
    {
        vector<int> result;
        stack<int> temp;
        
        while(head != nullptr)
        {
            temp.push(head->val);
            head = head->next;
        }
        
        while(!temp.empty())
        {
            result.push_back(temp.top());
            temp.pop();
        }
        
        return result;
    }
};
```



### 《剑指offer》—面试题18：删除链表的节点

##### 题目1：在O(1)时间内删除链表结点

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

##### 题目2：删除链表中重复的节点

```c++
/*
	题目描述：
	在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
*/
```

```c++
/*	
	解决方案1（三指针法）
	解决思路：
		首先确定的是链表是递增排序的，因此从小往后遍历处理即可。然后，要删除链表中重复的结点（需要注意只要是出现两次及以上相同数字的结点均删除），需要一个指向第一个重复结点的指针p1，一个指向最后一个重复结点的指针p2，以及存储p1指向前一个结点的位置的指针pre，通过移动和比较，删除链表中的重复结点。
	解决步骤：
		（1）首先处理特殊输入，输入的头指针为空，返回空指针
		（2）定义初始化三个指针p1，p2，pre（p1指向pHead，p2，pre为空）
		（3）设定循环终止条件为p1指向链表尾部
			（3.1）若p1指向的值与p1->next指向的值相同，且两者均不为空指针，将p1->next赋给p2
				（3.1.1）固定p1位置不动，移动p2到最后一个与p1指向值重复的结点为止
				（3.1.2）若此时p1指向的是头结点的位置（p1->...->p2->...），将pre指向p2->next
				（3.1.3）若此时p1指向的不是头结点的位置（...->p1->...->p2->...），将pre->next指向
				p2->next
				（3.1.4）删除第一个重复数值对应的结点后，开始下一个，因此需要将p1 = p2->next
			（3.2）若p1指向的值与p1->next指向的值不相同，则将当前p1指向赋给pre，继续往后移动p1
		（4）输出去重复结点的链表
			
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead == nullptr)
            return pHead;
        
        ListNode* pre = nullptr;
        ListNode* p1 = pHead;
        ListNode* p2 = nullptr;
        
        while(p1 != nullptr)
        {
            if(p1->next != nullptr; && p1->next->val == p1->val)
            {
                p2 = p1->next;
                
                while(p2 != nullptr && p2->next != nullptr; && p2->next->val == p1->val)
                {
                    p2 = p2->next;
                }
                
                if(p1 == pHead)
                    pre = p2->next;
                else
                    pre->next = p2->next;
                
                p1 = p2->next;
            }
            else
            {
                pre = p1;
                p1 = p1->next;
            }
        }
        
        return pHead;
    }
};
```

```c++
/*	
	解决方案2（递归+指针）
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead == nullptr)
            return nullptr;
        if(pHead != nullptr && pHead->next == nullptr)
            return pHead;
                 
        ListNode* current;
         
        if(pHead->next->val == pHead->val)
        {
            current = pHead->next->next;
            while(current != nullptr && current->val == pHead->val)
                current=current->next;
            return deleteDuplication(current);
        }
         
        else 
        {
            current = pHead->next;
            pHead->next = deleteDuplication(current);
            return pHead;
        } 
    }
};
```





### 《剑指offer》—面试题22：链表中倒数第k个节点

```c++
/*
	题目描述：
	输入一个链表，输出该链表中倒数第k个结点。
*/
```

```c++
/*	
	解决方案1（数学方法）
	解决思路：
		若总共有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。因此只需要遍历两次链表，第一次统计链表结点个数，第二次就能找到倒数第k个结点
		注意三个让代码崩溃的条件
		（1）头指针为空
		（2）k为0
		（3）k大于链表的总结点数
	解决步骤：
		（1）首先处理特殊输入，空指针，k为0，返回空指针
		（2）遍历链表，统计结点个数
		（3）判断k是否大于结点个数，是则返回空指针，否则进行下一步
		（4）遍历链表，终止位置为第n-k+1个结点位置
		（5）输出倒数第k个结点
		
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) 
    {
        if(pListHead == nullptr || k == 0)
            return nullptr;
        
        unsigned int numOfNode = 0;
        ListNode* temp = pListHead;
        while(temp->next != nullptr)
        {
            numOfNode++;
            temp = temp->next;
        }
        numOfNode++;
        
        if(k > numOfNode)
            return nullptr;
        
        ListNode* result = pListHead;
        for(unsigned int i=1; i<numOfNode-k+1; i++)
        {
            result = result->next;
        }
        return result;
    }
};
```

```c++
/*	
	解决方案2（双指针(或叫快慢指针)）
	解决思路：
		设定两个间隔始终为k-1的指针p1，p2，当p1指向链表的最后一个结点时，p2指向的刚好为倒数第k个结点的位置
	解决步骤：
		（1）首先考虑特殊输入，空指针和k=0
		（2）设置两个指针p1，p2并初始化
		（3）先移动p1至k-1位置，移动期间判断其next是否为空，若为空，但是循环未结束，说明k-1大于节点数目
		（4）设置p2指向链表头部，重新遍历链表，同时移动p1，p2，当p1指向链表尾部，p2指向倒数第k个结点
		（5）输出倒数第k个结点
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) 
    {
        if(pListHead == nullptr || k == 0)
            return nullptr;
        
        ListNode* p1 = pListHead;
        ListNode* p2 = nullptr;
        
        for(unsigned int i=0; i<k-1; i++)
        {
            if(p1->next != nullptr)
                p1 = p1->next;
            else
                return nullptr;
        }
        p2 = pListHead;
        
        while(p1->next != nullptr)
        {
            p1 = p1->next;
            p2 = p2->next;
        }
        
        return p2;
    }
};
```



### 《剑指offer》—面试题23：链表中环的入口节点

```c++
/*
	题目描述：
	给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
*/
```

```c++
/*	
	解决方案1（快慢指针）
	解决思路：
		（1）先通过快慢指针判断链表中是否存在环，
		（2）若存在则通过两者相遇的节点为计数起点，再次在此结点相遇时走过的次数即为环中结点的个数k，
		（3）再设置两个指针p1，p2，p1从头结点往前移动k步，然后再使p2指向头结点，两者以此固定间隔同时移动，直到两者相遇，即为环的入口结点。
	解决步骤：
		参考解决思路
*/
```

```c++
// c++11（clang++3.9）实现

/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        // 判断是否有环
        ListNode* meetingNode = MeetingNode(pHead);
        if(meetingNode == nullptr)
            return nullptr;
        
        // 统计环的结点个数
        int nodesOfLoop = 1;
        ListNode* P1 = meetingNode;
        while(P1->next != meetingNode)
        {
            P1 = P1->next;
            ++nodesOfLoop;
        }
        
        // 环的入口点
        P1 = pHead;
        for(int i=0; i<nodesOfLoop; ++i)
        {
            P1 = P1->next;
        }
         
        ListNode* P2 = pHead;
        while(P1 != P2)
        {
            P1 = P1->next;
            P2 = P2->next;
        }
        return P1;
        
    }
    
    /*
        利用快慢指针判断链表是否存在环，若存在则返回两个快慢指针的相遇结点
        若没有相遇结点则返回空
    */
    ListNode* MeetingNode(ListNode* pHead)
    {
        if(pHead == nullptr)
            return nullptr;
        
        ListNode* pSlow = pHead->next;
        if(pSlow == nullptr)
            return nullptr;
         
        ListNode* pFast = pSlow->next;
        
        while(pSlow != nullptr && pFast != nullptr)
        {
            if(pSlow = pFast)
                return pSlow;
            
            pSlow = pSlow->next;
            pFast = pFast->next;
            if(pFast != nullptr)
            {
                pFast = pFast->next;
            }
        }
        return nullptr;
    }
};
```



### 《剑指offer》—面试题24：反转链表

```c++
/*
	题目描述：
	输入一个链表，反转链表后，输出新链表的表头。
*/
```

```c++
/*	
	解决方案1（三指针法）
	解决思路：
		设置三个指针，一个指针存储当前结点，一个指针存储前一个结点，为防止断链，最后一个指针存储下一个结点，通过三个指针的移动，最后得到翻转的链表。
	解决步骤：
		参考解决思路
*/
```

```c++
// c++11（clang++3.9）实现


class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) 
    {
        if(pHead == nullptr)
            return nullptr;
        
        ListNode* pPre = nullptr;
        ListNode* pCur = pHead;
        ListNode* pReverseHead = nullptr;
        
        while(pCur != nullptr)
        {
            ListNode* pNext = pCur->next;
            if(pNext == nullptr)
                pReverseHead = pCur;
            
            // 
            pCur->next = pPre;
            pPre = pCur;
            pCur = pNext;
        }
        
        return pReverseHead;
    }
};
```



### 《剑指offer》—面试题25：合并两个排序的链表

```c++
/*
	题目描述：
	输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
	
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        
        if(pHead1 == nullptr)
            return pHead2;
        else if(pHead2 == nullptr)
            return pHead1;
        
        ListNode* pMergedHead = nullptr;
        if(pHead1->val < pHead2->val)
        {
            pMergedHead = pHead1;
            pMergedHead->next = Merge(pHead1->next,pHead2);
        }
        else
        {
            pMergedHead = pHead2;
            pMergedHead->next = Merge(pHead1,pHead2->next);
        }
        return pMergedHead;
    }
};
```



### 《剑指offer》—面试题35：复杂链表的复制

```c++
/*
	题目描述：
	输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
*/
```

```c++
/*	
	解决方案1（技巧分治）
	解决思路：
		（1）
		（2）
		（3）
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead)
    {
        CloneNodes(pHead);
        ConnectRandomNodes(pHead);
        return ReconnectNodes(pHead);
    }
    
    // （1）复制原始链表的任意结点N，并创建新街点N'，再把N’链接到N的后面
    void CloneNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        while(pNode != nullptr)
        {
            RandomListNode* pCloned = new RandomListNode(0);
            pCloned->label = pNode->label;
            pCloned->next = pNode->next;
            pCloned->random = nullptr;
            
            pNode->next = pCloned;
            pNode = pCloned->next;
        }
    }
    
    // （2）将原始链表的random指向复制到结点N'对应的random结点上
    void ConnectRandomNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        while(pNode != nullptr)
        {
            RandomListNode* pCloned = pNode->next;
            if(pNode->random != nullptr)
            {
                pCloned->random = pNode->random->next;
            }
            pNode = pCloned->next;
        }
    }
    
    // （3）拆分上面的长链表为两个链表
    RandomListNode* ReconnectNodes(RandomListNode* pHead)
    {
        RandomListNode* pNode = pHead;
        RandomListNode* pClonedHead = nullptr;
        RandomListNode* pClonedNode = nullptr;
        
        if(pNode != nullptr)
        {
            pClonedHead = pClonedNode = pNode->next;
            pNode->next = pClonedNode->next;
            pNode = pNode->next;
        }
        
        while(pNode != nullptr)
        {
            pClonedNode->next = pNode->next;
            pClonedNode = pClonedNode->next;
            pNode->next = pClonedNode->next;
            pNode = pNode->next;
        }
        return pClonedHead;
    }
    
};
```



### 《剑指offer》—面试题26：二叉搜索树与双向链表

```c++
/*
	题目描述：
	输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

------



## 哈希表

## 队列与栈

```c++
/*
	栈是限定仅在表尾进行插入和删除操作的线性表（后进先出 LIFO Last In First Out）
	（1）通常栈是一个不考虑排序的数据结构
	
	队列是只允许在一端进行操作，而在另一端进行删除操作的线性表（先进现出 FIFO First In First Out）
*/
```



### 《剑指offer》—面试题9：用两个栈实现队列

```c++
/*
	题目描述：
	用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型
*/
```

```c++
/*	
	解决方案1
	解决思路：
		根据队列的特点是先入先出，并且有入队和出队两个操作，我们利用两个栈来实现：
			（1）入队实现：直接push元素
    		（2）出队实现:
    			（2.1）栈1内元素出栈，保存
    			（2.2）栈2不为空，栈1出栈元素入栈2，保存
    			（2.3）栈2元素出栈，队列出队实现
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution
{
public:
    // 入队
    void push(int node) 
    {
        stack1.push(node);
    }
    // 出队
    int pop() 
    {
        int data;
        if(stack2.size() <= 0)
        {
            while(stack1.size() > 0)
            {
                data = stack1.top();     // 取出栈1顶部元素
                stack1.pop();            // 弹出栈1顶部元素
                stack2.push(data);       // 栈1顶部元素压入栈2
            }
        }
        
        if(stack2.size() == 0)
        {
            return false;
        }
        int head = stack2.top();    // 栈2顶部元素弹出即为队列出队
        stack2.pop();
        return head;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```



### 《剑指offer》—面试题30：包含min函数的栈

```c++
/*
	题目描述：
	定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））
*/
```

```c++
/*	
	解决方案1
	解决思路：
		（1）定义数据栈m_data和辅助栈m_min；
        （2）将读取的数值压入数据栈中，然后再处理辅助栈
        	（2.1）辅助栈为空，则把当前输入值压栈
            （2.2）辅助栈中的栈顶元素小于当前输入的值，则仍然将辅助栈顶元素压入辅助栈中
            （2.3）反之，元素压栈入辅助栈
        （3）重复步骤2，直到数据栈压入最后一个元素，同时，辅助栈的栈顶压入最小的元素，即可出栈
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    // 压栈
    void push(int value) 
    {
        m_data.push(value);
        if(m_min.empty())
            m_min.push(value);
        else if(m_min.top() < value)    // 比较辅助栈的栈顶元素与value
            m_min.push(m_min.top());
        else
            m_min.push(value);
    }
    
    // 弹出栈顶元素
    void pop() 
    {
        if(!m_data.empty())
        {
            m_data.pop();
            m_min.pop();
        }
    }
    
    // 取栈顶元素
    int top() 
    {
        return m_data.top();
    }
    
    int min() 
    {
        return m_min.top();
    }
private:
    stack<int> m_data;    // 数据栈
    stack<int> m_min;     // 辅助栈
};
```



### 《剑指offer》—面试题31：栈的压入、弹出序列

```c++
/*
	题目描述：
	输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
*/
```

```c++
/*	
	解决方案1
	解决思路：
		（1）定义一个辅助栈stackAssist，用于对输入的已经压栈的序列实行压栈和弹出操作
        （2）顺序读取一个压栈序列的pushV的元素，将其压入辅助栈stackAssist
        （3）然后将压入辅助栈的元素与弹出序列的元素依次对比，相等则弹出元素，不等则重复步骤（2）
        （4）判断辅助栈中的元素是否全部弹出，是则意味着压栈序列能实现弹出序列，否则不能
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) 
    {
        vector<int> stackAssist;
        for(int i=0,j=0; i<pushV.size();)
        {
            stackAssist.push_back(pushV[i++]);
            while(j<popV.size() && stackAssist.back() == popV[j])
            {
                stackAssist.pop_back();
                j++;
            }
        }
        return stackAssist.empty();
    }
};
```



### 《剑指offer》—面试题59：队列的最大值

##### 题目1：滑动窗口的最大值

```c++
/*
	题目描述：
	给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

#####  题目2：队列的最大值

# 

## 树

```c++
/*
	树是n个结点的有限集。n=0时为空树，有且仅有一个特定的根的结点。
	树的特点：
		（1）结点拥有的子树的数目称为结点的度；
			（1.1）度为0的结点称为叶结点。
			（1.2）度不为0的结点称为分支结点
			（1.3）树的度是树内各个结点的度的最大值
		（2）结点的层次从根开始定义，树种结点的最大层次称为树的深度（Depth）或高度
		
	树的遍历（以根节点所处位置命名）：
		（1）前序遍历：根-左-右
		（2）中序遍历：左-根-右
		（3）后序遍历：左—右-根
	
	树的分类：
		（1）二叉树：每个结点最多含有两颗子树的树称为二叉树。（左右子树是有顺序的）
		（2）特殊二叉树：
			（2.1）斜树：所有节点都只有左子节点或右子结点，称为左斜树或右斜树。
			（2.2）完全二叉树：对于一颗二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均
			已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
			（2.3）滿二叉树：所有的结点都存在左子树和右子树，并且所有的叶结点都在同一层上。
			（2.4）二叉搜索树：左子节点总是小于或等于根节点，右子节点总是大于或等于根节点。
			（2.5）平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树
			（2.6）堆：根节点最大（最大堆），根节点最小（最小堆）
			（2.7）红黑树：
*/
```



### 《剑指offer》—面试题7：重建二叉树

```c++
/*
	题目描述：
	输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
		先通过前序遍历序列的第一个元素即为根节点，遍历中序序列，找到其根节点位置后，将中序序列划分为左右子树对应的序列。根据中序序列的左右子序列可以将前序遍历序列也划分为左右子树序列，然后利用递归重复上述步骤，最终重建二叉树。
	解决步骤：
		（1）先考虑特殊输入，空序列，返回nullptr
		（2）定义四个动态数组和一个根节点，分别用于存储，左前序序列、左中序序列、右前序序列、右中序序列
		（3）遍历中序序列，找到根节点位置loc
		（4）根据根节点位置，分别将其存入初始化的四个动态数组中
		（5）分别对左前序序列，左中序序列进行递归，对右前序序列，右中序序列进行递归
		（6）重复步骤（2）-（5）重建二叉树。
*/
```

```c++
// c++11（clang++3.9）实现
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) 
    {
        vector<int> left_pre, left_vin, right_pre, right_vin;
        if(pre.empty() || vin.empty())
            return nullptr;
        
        TreeNode* root = new TreeNode(pre[0]);
        
        vector<int>::size_type loc = 0;
        for(vector<int>::size_type i = 0; i < vin.size(); i++){
            if(vin[i] == pre[0]){
                loc = i;
                break;
            }
        }
        // 左子树
        for(vector<int>::size_type i = 0; i < loc; i++){
            left_vin.push_back(vin[i]);
            left_pre.push_back(pre[i+1]);
        }
        // 右子树
        for(vector<int>::size_type i = loc + 1; i < vin.size(); i++){
            right_vin.push_back(vin[i]);
            right_pre.push_back(pre[i]);
        }
        
        root->left = reConstructBinaryTree(left_pre, left_vin);
        root->right = reConstructBinaryTree(right_pre, right_vin);
        
        return root;
    }
};
```

### 《剑指offer》—面试题8：二叉树的下一个节点

```c++
/*
	题目描述：
	给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
*/
```

```c++
/*	
	解决方案1
	解决思路：
		（1）判断该结点是否有右子树
        （2）有，则其中序遍历顺序中的下一个结点就是其右子树的最左结点
        （3）无，若该结点是其父亲结点的左子结点，则其中序遍历顺序中的下一个结点就是它的父结点
        （4）若该结点没有右子树，并且还是其父结点的右子结点，向上遍历直到结点为其父结点的左子结点
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(pNode == nullptr)
            return nullptr;
        
        TreeLinkNode* pNext = nullptr;
        // 该结点有右子树
        if(pNode->right != nullptr)
        {
            TreeLinkNode* pRight = pNode->right;
            while(pRight->left != nullptr)
            {
                pRight = pRight->left;
            }
            pNext = pRight;
        }
        // 该结点无右子树，且其父结点不为空
        else if(pNode->next != nullptr)
        {
            TreeLinkNode* pCurrent = pNode;
            TreeLinkNode* pParent = pNode->next;
            // 父结点不为空，且该结点为父结点的右子结点
            while(pParent != nullptr && pCurrent == pParent->right)
            {
                pCurrent = pParent;
                pParent = pParent->next;
            }
            // 其父结点的左子结点
            pNext = pParent;
        }
        return pNext;
    }
};
```

### 《剑指offer》—面试题26：树的子结构

```c++
/*
	题目描述：
	输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
		（1）首先，剔除特殊输入，传入的根结点指针1和2都不为空指针
        （2）比较树1与树2根节点的值，
        	（2.1）若相等，则继续判断树1的左子树和右子树结点是否与树2的对应结点的值相等
            	（递归实现，同时注意边界条件：左右子树结点是否存在，即是否为空指针），
            	存在子树则返回true，不存在则返回false
            （2.2）若不等，则继续递归遍历树1的左边，若能找到结点与树2根结点的值相等，则执行步（2.1），
            	反之，执行步骤（2.3）
            （2.3）若不等，则继续递归遍历树1的右边，若能找到结点与树2根结点的值相等，则执行步骤（2.1）
       （3）返回true则存在，返回false则不存在
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        bool result = false;
        if(pRoot1 != nullptr && pRoot2 != nullptr)
        {
            if(Equal(pRoot1->val, pRoot2->val))
                result = DoesTree1HaveTree2(pRoot1, pRoot2);
            if(!result)
                result = HasSubtree(pRoot1->left, pRoot2);
            if(!result)
                result = HasSubtree(pRoot1->right, pRoot2);
        }
        return result;
    }
    
    bool DoesTree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot2 == nullptr)
            return true;
        if(pRoot1 == nullptr)
            return false;
        if(!Equal(pRoot1->val, pRoot2->val))
            return false;
        return DoesTree1HaveTree2(pRoot1->left, pRoot2->left) && DoesTree1HaveTree2(pRoot1->right, pRoot2->right);
    }
    
    // 判断是否相等
    bool Equal(double num1, double num2)
    {
        if((num1 - num2 > -0.0000001) && (num1 - num2 < 0.0000001))
            return true;
        else
            return false;
    }
};
```

### 《剑指offer》—面试题27：二叉树的镜像

```c++
/*
	题目描述：
	操作给定的二叉树，将其变换为源二叉树的镜像。

	输入描述:
	二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
		（1）首先，判断两种特殊输入：
			1.根节点为空指针，返回None
            2.根节点不为空指针，但是根节点的左右子节点均为空指针，返回None
        （2）交换根节点的左、右子树
       	（3）递归执行步骤（1）（2），以当前结点为根节点判断其左右子树情况，存在在交换，不存在则终止
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    void Mirror(TreeNode *pRoot) 
    {
        if(pRoot == nullptr)
            return;
        if(pRoot->left == nullptr && pRoot->right == nullptr)
            return;
        
        TreeNode *pTemp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = pTemp;
        
        if(pRoot->left)
            Mirror(pRoot->left);
        
        if(pRoot->right)
            Mirror(pRoot->right);
    }
};
```

### 《剑指offer》—面试题28：对称的二叉树

```c++
/*
	题目描述：
	请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
*/
```

```c++
/*	
	解决方案1（前序遍历（根-左-右）与新版前序遍历序列对比（根-右-左），递归）
	解决思路：
		比较两种前序遍历序列是否相等，第一种为“根-左-右”，另一种为“根-右-左”。
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        return isSymmetrical(pRoot, pRoot);
    }
    
    bool isSymmetrical(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1 == nullptr && pRoot2 == nullptr)
            return true;
        
        if(pRoot1 == nullptr || pRoot2 == nullptr)
            return false;
        
        if(pRoot1->val != pRoot2->val)
            return false;
        
        return isSymmetrical(pRoot1->left, pRoot2->right) && isSymmetrical(pRoot1->right, pRoot2->left);
    }
};
```

### 《剑指offer》—面试题32：从上到下打印二叉树

##### 题目1：不分行从上到下打印二叉树

```c++
/*
	题目描述：
	从上往下打印出二叉树的每个节点，同层节点从左至右打印。
*/
```

```c++
/*	
	解决方案1（队列）
	解决思路：
	解决步骤：
		（1）定义一个辅助队列、整型容器和树结点指针，分别用于
         	存储二叉树当前根节点对应的子节点的元素
            存储最终输出的树序列
            遍历二叉树中的元素，
        （2）判断特殊输入
        （3）根节点指针压入队首
        （4）队首元素赋给treePtr，该指针指向的元素压入printTree中
        （5）遍历当前节点左右子节点是否为空，不为空则入队，反之不入队，并且将队首元素出队
*/
```

```c++
// c++11（clang++3.9）实现

/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) 
    {
        vector<int> printTree;            // 存储最终打印的树序列
        queue<TreeNode*> queueAssist;     // 临时队列容器
        TreeNode* treePtr;                // 遍历树的指针
        
        // 特殊输入
        if(root == nullptr)
            return printTree;
        
        queueAssist.push(root);               // 根节点入队
        while(!queueAssist.empty())
        {
            treePtr = queueAssist.front();    // 队首指针元素
            printTree.push_back(treePtr->val);
            
            if(treePtr->left != nullptr)
                queueAssist.push(treePtr->left);    // 入队
            if(treePtr->right != nullptr)
                queueAssist.push(treePtr->right);
            
            queueAssist.pop();    // 出队
        }
        return printTree;
    }
};
```

##### 题目2：分行从上到下打印二叉树

```c++
/*
	题目描述：
	从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行
*/
```

```c++
/*	
	解决方案1（队列）
	解决思路：
		利用队列的性质，先入先出，从上到下，从左到右依次遍历二叉树，每遍历一层，将其存入临时队列中，然后不断出队读取队头元素，实现分行从上到下打印二叉树。
	解决步骤：
		（1）处理特殊输入，空指针，返回空
		（2）定义一个二维动态数组、树结点指针队列，分别用于存储分行打印的树以及临时存储每行的树结点对应的元素
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) 
        {
            vector<vector<int> > result;
            if(pRoot == nullptr) 
                return result;
            
            queue<TreeNode*> q;
            q.push(pRoot);
            
            while(!q.empty())
            {
                int size = q.size();    //读取每一层的元素的数量
                vector<int> temp;
                while(size--)
                {
                    TreeNode* pNode = q.front();    // 队列的头元素
                    q.pop();                        // 队头出队
                    temp.push_back(pNode->val);
                    if(pNode->left != nullptr) 
                        q.push(pNode->left);
                    if(pNode->right != nullptr) 
                        q.push(pNode->right);
                }
                result.push_back(temp);
            }
            return result;
        }
     
};
```



##### 题目3：之字形打印二叉树

```c++
/*
	题目描述：
	请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
*/
```

```c++
/*	
	解决方案1（栈）
	解决思路：
		根据题目可知，奇数行从左往右打印，偶数行从右往左打印。利用栈的后进现出特性，声明两个栈，一个栈负责上一层，一个栈负责下一层，每打印完一层保存并清空。
	解决步骤：
		（1）首先处理特殊输入，空指针
		（2）初始化两个栈s1，s2，用于遍历树的指针pNode，用于临时存储每层树的结点的值的动态数组tmp
		（3）先将根节点的值存入result中，并且将根节点压入s1中，用于对树的下一层进行遍历
		（4）判断s1或s2不为空
			（4.1）若s1不为空，说明栈1存在值，进行出栈，并按从右到左的顺序先后压入到s2中，并将对应的值
			压入tmp中，循环执行（4.1）直到s1为空，说明打印完这一层元素
			（4.2）若s2不为空，说明栈2存在值，进行出栈，并按从左到右的顺序先后压入到s1中，并将对应的值
			压入tmp中，循环执行（4.2）直到s2为空，说明打印完这一层元素
			（4.3）在执行（4.1）或（4.2）后，每次都要清空tmp便于存储和打印下一层的元素
		（5）循环执行（4）直到s1，s2均为空，此时说明已经打印完毕
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) 
    {
        vector<vector<int> > result;
        if(pRoot == nullptr) 
            return result;
        
        stack<TreeNode*> s1, s2;
        TreeNode* pNode;           // 用于遍历树的指针
        vector<int> tmp;           // 用于临时存储每层树的元素
        
        tmp.push_back(pRoot->val);// 保存根节点的元素值
        result.push_back(tmp);    // 先压入根节点
        tmp.clear();              // 清空临时动态数组
        
        s1.push(pRoot);
        while(!s1.empty() || !s2.empty())
        {
            while(!s1.empty())
            {
                pNode = s1.top();
                s1.pop();
                if(pNode->right)
                {
                    s2.push(pNode->right);
                    tmp.push_back(pNode->right->val);
                }
                if(pNode->left)
                {
                    s2.push(pNode->left);
                    tmp.push_back(pNode->left->val);
                }
            }
            
            if(!tmp.empty()) 
            {
                result.push_back(tmp);
                tmp.clear();
            }
            
            while(!s2.empty())
            {
                pNode = s2.top();
                s2.pop();
                if(pNode->left)
                {
                    s1.push(pNode->left);
                    tmp.push_back(pNode->left->val);
                }
                if(pNode->right)
                {
                    s1.push(pNode->right);
                    tmp.push_back(pNode->right->val);
                }
            }
            
            if(!tmp.empty())
            {
                result.push_back(tmp);
                tmp.clear();
            }
        }
        return result;   
    }
     
};
```

### 《剑指offer》—面试题33：二叉搜索树的后序遍历序列

```c++
/*
	题目描述：
	输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
		首先得直到二叉搜索树是什么？二叉搜索树的左子节点小于根节点，根节点小于右子节点。后序遍历序列的最后一个数字是根节点的值，由此将序列划分为两部分
	解决步骤：（输入为后序遍历序列）
		（1）定义两个序列分别用于存储左子树和右子树
        （2）保存根节点用于和输入的后序遍历序列进行比较划分左右子树序列
        （3）通过左子树序列中任意一个值小于根节点的值，右子树序列中的任意一个值大于于根节点的值，进行左右
        子序列划分
        （4）然后再将当前左右子序列进行递归步骤（2）-（3），判断左右子树是否都是二叉搜索树
        （5）若返回true则该后序遍历序列为某二叉搜索树的后序遍历结果，反之则不是
         */
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) 
    {        
        vector<int> leftSeq;
        vector<int> rightSeq;
        
        if(sequence.empty())
            return false;
        
        int root = sequence.back();
        
        // 左子树序列（元素应全部小于根节点的值）
        vector<int>::size_type i = 0;
        for(; i < sequence.size()-1; ++i)
        {
            if(sequence[i] > root)
                break;
            leftSeq.push_back(sequence[i]);
        }
        
        // 右子树序列（元素应全部大于根节点的值）
        vector<int>::size_type j = i;
        for(; j < sequence.size()-1; ++j)
        {
            if(sequence[j] < root)
                return false;
            rightSeq.push_back(sequence[j]);
        }
        
        // 判断左子树是不是二叉搜索树
        bool left = true;
        if(i > 0)
            left = VerifySquenceOfBST(leftSeq);
        
        // 判断左子树是不是二叉搜索树
        bool right = true;
        if(i < sequence.size()-1)
            right = VerifySquenceOfBST(rightSeq);
        
        return (left && right);
    }
};
```



### 《剑指offer》—面试题34：二叉树中和为某一值的路径

```c++
/*
	题目描述：
	输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
*/
```

```c++
/*	
	解决方案1（递归）
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) 
    {
        if(root == nullptr)
            return path;
        
        tmp.push_back(root->val);
        // 如果是叶结点，则保存当前路径
        if((expectNumber - root->val)==0 && root->left==nullptr && root->right==nullptr)
        {
            path.push_back(tmp);
        }
        FindPath(root->left, expectNumber - root->val);
        FindPath(root->right, expectNumber - root->val);
        if(tmp.size() != 0)
            tmp.pop_back();    // 在返回父结点之前，在路径上删除当前结点
        return path;
    }
private:
    vector<vector<int> > path;
    vector<int> tmp;
};
```

### 《剑指offer》—面试题37：序列化二叉树

```c++
/*
	题目描述：
	请实现两个函数，分别用来序列化和反序列化二叉树
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

### 《剑指offer》—面试题54：二叉搜索树的第k大节点

```c++
/*
	题目描述：
	给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(pRoot == nullptr || k == 0)
            return nullptr;
        
        return KthNodeCore(pRoot, k);
    }
    
    TreeNode* KthNodeCore(TreeNode* pRoot, int &k)
    {
        TreeNode* target = nullptr;
        
        if(pRoot->left != nullptr)
            target = KthNodeCore(pRoot->left, k);
        
        if(target == nullptr)
        {
            if(k == 1)
                target = pRoot;
            k--;
        }
        
        if(target == nullptr && pRoot->right != nullptr)
            target = KthNodeCore(pRoot->right, k);
        
        return target;
    }
};
```

### 《剑指offer》—面试题55：二叉树的深度

```c++
/*
	题目描述：
	输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == nullptr)
            return 0;
        
        int nLeft = TreeDepth(pRoot->left);
        int nRight = TreeDepth(pRoot->right);
        
        return (nLeft > nRight)?(nLeft + 1):(nRight + 1);
    }
};
```

### 《剑指offer》—案例二：树中两个节点的最低公共祖先

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

------



## 图



# 算法与数据操作

```c++
/*
	算法：解决特定问题求解步骤的描述
	算法的基本特性：输入、输出、有穷性、确定性和可行性
	算法的设计要求：正确性、可读性、健壮性
	
	时间复杂度
	空间复杂度
*/
```

## 递归与迭代

```c++
/*
	1.递归
		定义：程序调用自身的编程技巧称为递归（recursion）
		
		基本原理：
		（1）每一级的函数调用都有自己的变量。
		（2）每一次函数调用都会有一次返回。
		（3）递归函数中，位于递归调用前的语句和各级被调用函数具有相同的执行顺序。
		（4）递归函数中，位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反。
		（5）虽然每一级递归都有自己的变量，但是函数代码并不会得到复制。
		
		优缺点：
		（1）优点
			（1.1）实现简单
			（1.2）可读性好
		（2）缺点
			（2.1）递归调用，占用空间大
			（2.2）递归太深，易发生栈溢出
			（2.3）可能存在重复计算
			
		三大要素：
			（1）明确你这个函数想要干什么
			（2）寻找递归结束条件
			（3）找出函数的等价关系式
			
*/
```

![](E:\2---求职\附件\递归的过程.png)

```c++
/*
	2.迭代
*/
```



## 位运算

## 回溯法

## 查找

## 排序

```c++
/*
	排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序（可以进行比较，例如整数，浮点数，字符串等）（增加，非递减，递减， 增加，词典等）。
*/
```

### 基于比较的排序算法:

#### 	BUB - 冒泡排序

#### 	SEL - 选择排序

#### 	INS - 插入排序

#### 	MER - 归并排序 

```c++
/*
	将两个的有序数列合并成一个有序数列，我们称之为"归并"
	归并排序是建立在归并操作上的一种有效的排序算法。
	该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
*/
```

[归并排序详解](<https://www.cnblogs.com/skywang12345/p/3602369.html>)

#### 	QUI - 快速排序

#### 	R-Q - 随机快速排序 

### 不基于比较的排序算法:

#### 	COU - 计数排序

#### 	RAD - 基数排序

## 贪心

## 分治

## 动态规划

