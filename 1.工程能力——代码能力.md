# 高质量代码

## 规范性

## 完整性

## 鲁棒性

# 数据结构

```c++
/*
	数据：描述客观事物的符号。
	数据元素：组成数据的、有一定意义的基本单位。
	数据项：一个数据元素可以由若干个数据项组成。（数据不可分割的最小单位）
	数据对象：是性质相同的数据元素的集合，是数据的子集。
	数据结构：是相互之间存在一种或多种特定关系的数据元素的集合
*/
```

![](E:\2---求职\附件\数据结构.png)

```C++
/*
	抽象数据类型 ADT
	标准格式：
		ADT 抽象数据类型名
		Data
			数据元素之间逻辑关系的定义
		Operation
			操作1
				初始条件
				操作结果描述
			操作2
				......
			操作n
				......
		endADT
*/
```

## 数组

```C++
/*
	数组：占据一块连续的内存并按照顺序存储数据
		创建数组需要指定数组的容量大小
*/
```

### 《剑指offer》—面试题3：数组中重复的数字

```C++
/*
	题目描述：
	在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为6的数{2,3,1,0,2,5}，那么对应的输出是第一个重复的数字2。
	
*/ 
```

```C++
/*	
	解决方案1（暴力解法）
	解决思路：
		对数组进行排序，然后从头到尾扫描数组，并将其与需要查重的元素进行对比，若相等，且数组本身有存在该元素的重复值，则找到需要寻找的重复元素
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）对数组进行排序
		（3）遍历数组，进行前后元素对比，若前后元素相等，返回true，反之进行遍历到数组末尾
		（4）若遍历到末尾，无重复元素，则返回false
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        // 边界条件
        if(numbers == nullptr || length < 0)
            return false;
        
        for(int i=0; i<length; i++)
        {
            if(numbers[i] < 0 || numbers[i] > length - 1)
                return false;
        }
        
        
        sort(numbers, numbers + length);
        
        for(int i=0; i<length; i++)
        {
            if(numbers[i] == numbers[i+1])
            {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```

```python
# python2.7.3实现

# -*- coding:utf-8 -*-
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        # write code here
        # 边界条件
        if len(numbers) <= 0:
            return False
        
        for num in numbers:
            if (num < 0) or (num > len(numbers)-1):
                return False
        
        # 对数组排序
        numbers.sort()
        
        for i in range(len(numbers) - 1):
            if numbers[i] == numbers[i+1]:
                duplication[0] = numbers[i]
                return True
        
        return False    
```

```c++
/*	
	解决方案2（技巧解法）
	解决思路：
		由于数组中的数字被限定在0~n-1的范围内，若数组中不存在重复元素，那么数组进行排序后，第i个位置存放的应该是元素i。
		基于上述思路，采用以下解题思路：
			从头到尾部遍历数组的元素，将扫描到下标为i的数字时，首先比较该数字（用m表示）是不是等于i。
			如果是，则扫描下一个数字；
			如果不是，则拿它和第m个数字进行比较，如果它与第m个数字相等，则找到第一个重复数字；
			如果不等，则将第i个数字和第m个数字进行交换，把m放回属于它的位置；
			然后重复上述步骤，直到我们发现第一个重复的数字
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）如解决思路中阐述
		
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        // 特殊输入
        if(numbers == nullptr || length < 0)
            return false;
         
        // 边界条件
        for(int i=0; i<length; i++)
        {
            if(numbers[i] < 0 || numbers[i] > length - 1)
                return false;
        }
        
        //
        for(int i=0; i<length; i++)
        {
            while(numbers[i] != i)
            {
                if(numbers[i] == numbers[numbers[i]])
                {
                    *duplication = numbers[i];
                    return true;
                }
            
                int temp = numbers[i];
                numbers[i] = numbers[temp];
                numbers[temp] = temp;
            }
        }
        return false;
    }
};
```

```c++
/*	
	解决方案3（哈希表实现）
	解决思路：
		构建简单的哈希表，从头到尾遍历数组元素，扫描到元素m时，在哈希表中对应的m位置加1，直到数组扫描完毕后，判断哈希表中大于1的元素，并在数组中找到其对应的元素记为重复的元素即可
		
	注意：这种解法并不使用于数组元素很多很多的时候，因为哈希表需要初始设定其容量大小
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）对数组元素遍历并统计每个元素出现的次数存入哈希表中
		（3）遍历哈希表，找出次数大于1的对应在数组中的元素
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) 
    {
        if(numbers == nullptr|| length <= 0) 
            return false;
        
        int hashTable[255] = {0};
        
        for(int i=0; i<length; i++)
        {
            hashTable[numbers[i]]++;
        }

        for(int i=0; i<length; i++)
        {
            if(hashTable[numbers[i]] > 1)
            {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};
```



### 《剑指offer》—面试题4：二维数组中的查找

```c++
/*
	题目描述：
	在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
*/ 
```

```c++
/*	
	解决方案1
	解决思路：
		利用题目描述中二维数组的特性，从左往右的每行和从上往下的每列都递增，因此可以选择从数组的右上角或左下角开始比较判断，剔除相应的行和列，最终能定位到相应的元素。
	解决步骤：（可以从左下角开始，思路一致）
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）定位到数组（n行xn列）的右上角，将其与目标元素进行比较
			（2.1）若目标元素等于数组右上角的元素，则返回真
			（2.2）若目标元素大于数组右上角的元素，则剔除右上角元素所在行，可选元素的数组为n-1行Xn-1列
			（2.3）若目标元素小于数组右上角的元素，则剔除右上角元素所在列，可选元素的数组为n-1行Xn-1列
		（3）循环执行步骤（2），最终得到数组中存在目标元素，返回真，否则返回假
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    bool Find(int target, vector<vector<int> > array) 
    {
        int rows = array.size();
        int cols = array[0].size();
        if(array.empty())
        {
            return false;
        }
        
        int row = 0;
        int col = cols - 1;
        
        while(row < rows && col >=0)
        {
            if(array[row][col] == target)
            {
                return true;
            }
            else if(array[row][col] > target)
            {
                --col;
            }
            else
                ++row;
        }
        return false;
    }
};
```



### 《剑指offer》—面试题11：旋转数组的最小数字

```c++
/*
	题目描述：
	把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/ 
```

```c++
/*	
	解决方案1（双指针法~二分查找）
	解决思路：
		根据题目描述，输入的为一个非减排序旋转数组，
		（1）可将其看作两个递增子数组。利用两个指针P1,P2分别指向旋转数组的头尾，将P1和P2的中间元素与P1（或P2）指向的元素不断比较，直到P1与P2相邻，且P1在P2前面，此时P2指向的元素为旋转数组最小的元素。
		（2）当不能将其看作两个递增子数组时，只能采用顺序查找的方法。
	解决步骤：
		（1）处理特殊输入与边界条件（数组长度，数组元素范围）
		（2）设置两个指针p1,p2分别指向旋转数组的头尾，并设置另一个指针mid=p1;
		（3）开始循环移动p1，p2，终止条件为p1大于p2
			（3.1）如果p2-p1==1，说明此时p2已经指向了旋转数组的最小元素，直接输出
			（3.2）若p1，p2，mid指向的元素均相等，此时的旋转数组划分为两个递增子数组，采用顺序查找方法
			（3.3）若p1指向的元素小于mid指向的元素，说明此时的mid指向的元素位于前面的子数组，将p1=mid
			（3.3）若p2指向的元素大于mid指向的元素，说明此时的mid指向的元素位于后面的子数组，将p2=mid
		（4）循环结束后，输出最小元素
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) 
    {
        if(rotateArray.size() == 0)
            return 0;
        
        int p1 = 0;
        int p2 = rotateArray.size() - 1;
        int mid = p1;    // 当旋转数组仍然为非减排序数组时，第一个元素就是最小元素
        
        while(rotateArray[p1] >= rotateArray[p2])
        {
            if(p2 - p1 == 1)
            {
                mid = p2;
                return rotateArray[mid];
            }
            
            int mid = ( p1 + p2) / 2;
            // 三个位置的元素都相等，只能采用顺序查找
            if(rotateArray[p1] == rotateArray[mid] && rotateArray[p2] == rotateArray[mid])
                return MinInOrder(rotateArray);
            
            // 中间元素位于前面的递增子数组
            if(rotateArray[p1] <= rotateArray[mid])
                p1 = mid;
            
            // 中间元素位于后面的递增子数组
            else if(rotateArray[p2] >= rotateArray[mid])
                p2 = mid;
        }
        return rotateArray[mid];
    }
    
    int MinInOrder(vector<int> array)
    {
        int tmp = array[0];
        int length = array.size();
        for(int i=1; i<length; i++)
        {
            if(tmp > array[i])
                tmp = array[i];
        }
        return tmp;
    }
};
```



### 《剑指offer》—面试题21：调整数组顺序使奇数位于偶数前面

```c++
/*
	题目描述：
	输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
*/
```

```c++
/*	
	解决方案1（双指针法）
	解决思路：
		根据题目描述，要求最终得到的数组为前半部分全是奇数，后半部分全是偶数。可定义两个指针p1，p2分别指向数组的头尾，若p1指向偶数，p2指向奇数，则交换二者指向的元素，其他情况不交换，p1不断往后移，p2不断往前移直到所有的奇数交换到数组前半部分。
	解决步骤：
		（1）
		（2）
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    void reOrderArray(vector<int> &array) 
    {
        
    }
};
```

```c++
/*	
	解决方案2（中间动态数组法）
	解决思路：
		根据题目描述，要求最终得到的数组为前半部分全是奇数，后半部分全是偶数。定义一个新的动态数组，先后两次遍历数组，第一次取出所有奇数存入新数组，第二次取出所有偶数存入新数组，最后把新数组赋值给原数组
	解决步骤：
		（1）处理特殊输入（数组长度），并定义新的动态数组result
		（2）第一次遍历数组，取出奇数存入result
		（3）第二次遍历数组，取出偶数存入result
		（4）result赋给原数组
*/
```

```c++
// c++11（clang++3.9）实现

class Solution{
public:
    void reOrderArray(vector<int> &array) 
    {
        vector<int> result;
        int length = array.size();
        if(length == 0)
            return;
        
        for(int i=0; i<length; i++)
        {
            if(array[i] % 2 == 1)
                result.push_back(array[i]);
        }
        for(int i=0; i<length; i++)
            {
            if(array[i] % 2 == 0)
                result.push_back(array[i]);
        }
        array = result;
    }
};
```



### 《剑指offer》—面试题39：数组中出现次数超过一半的数字

```c++
/*
	题目描述：
	数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
*/
```

```c++
/*	
	解决方案1
	解决思路：
		根据题目
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```



### 《剑指offer》—面试题42：连续子数组的最大和

```c++
/*
	题目描述：
	HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
*/
```

```c++
/*	
	解决方案1（分析数组的规律）
	解决思路：
		根据题目描述，得到数组中连续元素相加的最大和，注意不能交换数组中元素的位置。从前到后遍历数组，每累加一次元素，计算出一个和，并将其与上一次的和进行比较，若和为负数，则舍弃该和，从该元素的下一个元素重新开始累加；若和为整数，则继续不断累加，不断比较每次累加的和，比较得出最大和
	解决步骤：
		（1）处理特殊输入（数组长度），并定义当前与最后的最大和
		（2）从头到尾遍历数组
			（2.1）若当前最大和为负数，舍弃当前最大和，将其重新赋值为数组下一个元素
			（2.2）若当前最大和为非负数，保留当前最大和，继续累加
			（2.3）比较当前最大和与最后最大和，更新最后最大和
		（3）输出最后最大和
*/
```

```c++
// c++11（clang++3.9）实现

class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) 
    {
        int length = array.size();
        if(length == 0)
            return 0;
        
        
        int lastGreatestSum = 0x80000000;
        int curGreatestSum = 0;
        for(int i=0; i<length; i++)
        {
            // 若当前求和为负数，舍弃当前和，将其设置为数组下一个元素
            if(curGreatestSum < 0)
                curGreatestSum = array[i];
            // 若当前求和为非负数，保留当前和，继续累加
            else
                curGreatestSum += array[i];
            
            if(curGreatestSum > lastGreatestSum)
                lastGreatestSum = curGreatestSum;
        }
        return lastGreatestSum;
    }
};
```

### 《剑指offer》—面试题45：把数组排成最小的数

### 《剑指offer》—面试题51：数组中的逆序对

```c++
/*
	题目描述：
	在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
	
	输入描述:
		题目保证输入的数组中没有的相同的数字

		数据范围：
			对于%50的数据,size<=10^4
			对于%75的数据,size<=10^5
			对于%100的数据,size<=2*10^5
			
*/
```

```c++
/*	
	解决方案1（分治+归并排序）
	解决思路：
		根据题目描述，首先将数组划分为
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```

### 《剑指offer》—面试题53：在排序数组中查找数字

### 《剑指offer》—面试题56：数组中数字出现的次数

### 《剑指offer》—面试题57：和为s的数字

### 《剑指offer》—面试题66：构建乘积数组

## 字符串

```c++
/*
	题目描述：
*/
```

```c++
/*	
	解决方案1
	解决思路：
	解决步骤：
*/
```

```c++
// c++11（clang++3.9）实现
```



## 链表

## 哈希表

## 队列与栈

## 树

## 图

# 算法与数据操作

```c++
/*
	算法：解决特定问题求解步骤的描述
	算法的基本特性：输入、输出、有穷性、确定性和可行性
	算法的设计要求：正确性、可读性、健壮性
	
	时间复杂度
	空间复杂度
*/
```

## 递归与循环

## 位运算

## 回溯法

## 查找

## 排序

```c++
/*
	排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序（可以进行比较，例如整数，浮点数，字符串等）（增加，非递减，递减， 增加，词典等）。
*/
```

### 基于比较的排序算法:

#### 	BUB - 冒泡排序

#### 	SEL - 选择排序

#### 	INS - 插入排序

#### 	MER - 归并排序 

```c++
/*
	将两个的有序数列合并成一个有序数列，我们称之为"归并"
	归并排序是建立在归并操作上的一种有效的排序算法。
	该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
*/
```

[归并排序详解](<https://www.cnblogs.com/skywang12345/p/3602369.html>)

#### 	QUI - 快速排序

#### 	R-Q - 随机快速排序 

### 不基于比较的排序算法:

#### 	COU - 计数排序

#### 	RAD - 基数排序

## 贪心

## 分治

## 动态规划

